"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = useGSAPAnimateStroke;

var _gsap = require("gsap");

var _react = require("react");

var durations = [0.05, 0.3, 0.6, 0.05];

function useGSAPAnimateStroke(_ref) {
  var length = _ref.length,
      totalLength = _ref.totalLength,
      speed = _ref.speed;
  var speeds = (0, _react.useMemo)(function () {
    return durations.map(function (duration) {
      return speed * duration;
    });
  }, [speed]);
  return (0, _react.useCallback)(function (_ref2) {
    var timeline = _ref2.timeline,
        elem = _ref2.elem,
        strokeWidth = _ref2.strokeWidth;
    timeline.set(elem, {
      attr: {
        "stroke-dasharray": "0 ".concat(totalLength),
        "stroke-dashoffset": 0
      }
    });
    timeline.fromTo(elem, speeds[0], {
      attr: {
        "stroke-width": 0
      }
    }, {
      attr: {
        "stroke-width": strokeWidth
      }
    });
    timeline.to(elem, {
      keyframes: [{
        attr: {
          "stroke-dasharray": "".concat(length, " ").concat(totalLength - length),
          "stroke-dashoffset": -20
        },
        duration: speeds[1],
        ease: _gsap.Power4.easeIn
      }, {
        attr: {
          "stroke-dasharray": "0 ".concat(totalLength),
          "stroke-dashoffset": totalLength * -1
        },
        duration: speeds[2],
        ease: _gsap.Power4.easeOut
      }]
    }, "<");
    timeline.to(elem, speeds[3], {
      attr: {
        "stroke-width": 0
      }
    }, "-=".concat((speeds[1] + speeds[2]) * 0.3));
  }, [length, speeds, totalLength]);
}
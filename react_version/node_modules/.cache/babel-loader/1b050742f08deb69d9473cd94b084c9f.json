{"ast":null,"code":"import _ from 'lodash';\nimport { combineReducers } from 'redux';\nimport { createSelector } from 'reselect';\nimport binding, { setBinding } from './binding';\nimport nodes from './nodes';\nimport { getAllDescendantIds, getDescendantIds, getAllChildIds, getAllSiblingIds, getLeftSiblingId, getLeftSiblingIds, getRightSiblingId, getRightSiblingIds, getParentIds, getParentId, getIndexes, orderedNodeList } from './nodes/helpers';\nimport { createNode, updateNode, deleteNode, clearNodes, moveNode, moveNodeUp, moveNodeDown, indentNode, unindentNode } from './nodes';\nimport { types } from './nodes/types';\nconst {\n  CREATE_NODE,\n  DELETE_NODE,\n  UPDATE_NODE,\n  CLEAR_NODES,\n  CREATE_NODE_PATH,\n  MOVE_NODE,\n  MOVE_NODE_DOWN,\n  MOVE_NODE_UP,\n  INDENT_NODE,\n  UNINDENT_NODE\n} = types;\nconst BINDING_SET = 'HIERARCHY/BINDING/SET';\nconst combined = combineReducers({\n  binding,\n  nodes\n});\n\nconst getBinding = (state, action) => {\n  if (state.binding && _.size(state.binding)) {\n    if (Object.values(types).includes(action.type) && action.path) {\n      return state.binding[action.path];\n    }\n  }\n\n  return false;\n};\n\nexport const hierarchy = function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  const {\n    path,\n    type,\n    payload\n  } = action;\n  const newState = combined(state, action);\n\n  if (action.type === BINDING_SET) {\n    return combined(newState, {\n      path: payload.path,\n      type: CREATE_NODE_PATH\n    });\n  }\n\n  if (type === UNINDENT_NODE) {\n    const bound = getBinding(state, action);\n\n    if (bound) {\n      payload.googleStyle = bound.googleStyle;\n    }\n  }\n\n  if (newState.binding && _.size(newState.binding) && _.size(newState.nodes)) {\n    _.forEach(newState.binding, (data, dataPath) => {\n      if (data.indexing && dataPath === path) {\n        if (newState.nodes[dataPath] && _.size(newState.nodes[dataPath])) {\n          if ([CREATE_NODE, DELETE_NODE, MOVE_NODE, MOVE_NODE_DOWN, MOVE_NODE_UP, INDENT_NODE, UNINDENT_NODE].includes(type) || type === UPDATE_NODE && action.payload && _.pick(action.payload, ['parent', 'at', 'first', 'before', 'after']).length) {\n            newState.nodes[dataPath] = getIndexes(newState.nodes[dataPath]);\n          }\n        }\n      }\n    });\n  }\n\n  return newState;\n};\nexport const hierarchyMiddleware = store => next => action => {\n  let nodePayload;\n\n  if ([CREATE_NODE, DELETE_NODE, UPDATE_NODE, CLEAR_NODES].includes(action.type)) {\n    const state = store.getState();\n\n    if (state.hierarchy) {\n      const bindings = state.hierarchy.binding;\n      const {\n        type,\n        path\n      } = action;\n      let {\n        payload\n      } = action;\n\n      if (bindings && path) {\n        const bound = bindings[path];\n\n        if (bound) {\n          if (type !== CLEAR_NODES) {\n            if (type === CREATE_NODE && payload === undefined) {\n              payload = {};\n            }\n\n            if (payload.id === undefined) {\n              payload.id = _.uniqueId();\n            } else if (_.isArray(payload.id)) {\n              _.forEach(payload.id, (value, index) => {\n                payload.id[index] = _.toString(value);\n              });\n            } else {\n              payload.id = _.toString(payload.id);\n            }\n          }\n\n          nodePayload = _.pick(payload, ['id', 'parent', 'at', 'first', 'before', 'after']);\n\n          const dataPayload = _.omit(payload, ['parent', 'at', 'first', 'before', 'after', 'afterIndex', 'cascade', 'cascadeProp', 'cascadeLength']);\n\n          let boundActionType;\n\n          switch (type) {\n            case CREATE_NODE:\n              boundActionType = bound.createAction;\n              break;\n\n            case DELETE_NODE:\n              boundActionType = bound.deleteAction;\n              break;\n\n            case UPDATE_NODE:\n              boundActionType = bound.updateAction;\n              break;\n\n            case CLEAR_NODES:\n              boundActionType = bound.clearAction;\n              break;\n\n            default:\n              {\n                boundActionType = undefined;\n              }\n          }\n\n          if (boundActionType) {\n            if (type === UPDATE_NODE) {\n              const {\n                cascadeLength\n              } = payload;\n              let {\n                cascade,\n                cascadeProp\n              } = payload;\n\n              if (cascade) {\n                const boundNodes = state.hierarchy.nodes[path];\n\n                if (cascadeProp === undefined) {\n                  cascadeProp = _.omit(dataPayload, ['id']);\n                } else if (_.isArray(cascadeProp)) {\n                  cascadeProp = _.omit(_.pick(dataPayload, cascadeProp), ['id']);\n                }\n\n                let ids = [];\n\n                if (!_.isArray(cascade)) {\n                  cascade = [cascade];\n                }\n\n                _.forEach(cascade, dir => {\n                  if (['left', 'right', 'up', 'down'].includes(dir) && cascadeLength) {\n                    switch (dir) {\n                      case 'left':\n                        {\n                          ids = [...ids, ...getLeftSiblingIds(boundNodes, payload.id, cascadeLength)];\n                          break;\n                        }\n\n                      case 'right':\n                        {\n                          ids = [...ids, ...getRightSiblingIds(boundNodes, payload.id, cascadeLength)];\n                          break;\n                        }\n\n                      case 'up':\n                        {\n                          ids = [...ids, ...getParentIds(boundNodes, payload.id, cascadeLength)];\n                          break;\n                        }\n\n                      case 'down':\n                        {\n                          ids = [...ids, ...getDescendantIds(boundNodes, payload.id, cascadeLength)];\n                          break;\n                        }\n\n                      default:\n                        {\n                          ids = [];\n                        }\n                    }\n                  } else if (['root', 'parent', 'children', 'descendants', 'siblings', 'leftSiblings', 'rightSiblings', 'leftSibling', 'rightSibling'].includes(dir)) {\n                    switch (dir) {\n                      case 'root':\n                        {\n                          ids = [...ids, ...getParentIds(boundNodes, payload.id)];\n                          break;\n                        }\n\n                      case 'parent':\n                        {\n                          ids = [...ids, getParentId(boundNodes, payload.id)];\n                          break;\n                        }\n\n                      case 'children':\n                        {\n                          ids = [...ids, ...getAllChildIds(boundNodes, payload.id)];\n                          break;\n                        }\n\n                      case 'descendants':\n                        {\n                          ids = [...ids, ...getAllDescendantIds(boundNodes, payload.id)];\n                          break;\n                        }\n\n                      case 'siblings':\n                        {\n                          ids = [...ids, ...getAllSiblingIds(boundNodes, payload.id)];\n                          break;\n                        }\n\n                      case 'leftSiblings':\n                        {\n                          ids = [...ids, ...getLeftSiblingIds(boundNodes, payload.id)];\n                          break;\n                        }\n\n                      case 'rightSiblings':\n                        {\n                          ids = [...ids, ...getRightSiblingIds(boundNodes, payload.id)];\n                          break;\n                        }\n\n                      case 'leftSibling':\n                        {\n                          ids = [...ids, getLeftSiblingId(boundNodes, payload.id)];\n                          break;\n                        }\n\n                      case 'rightSibling':\n                        {\n                          ids = [...ids, getRightSiblingId(boundNodes, payload.id)];\n                          break;\n                        }\n\n                      default:\n                        {\n                          ids = [];\n                        }\n                    }\n                  }\n                });\n\n                if (ids.length) {\n                  let updatedData;\n                  let updatedNode;\n\n                  if (_.isFunction(cascadeProp)) {\n                    updatedNode = { ...boundNodes[payload.id]\n                    };\n                    updatedData = { ..._.get(state, `${path}.${payload.id}`)\n                    };\n                  }\n\n                  _.forEach(ids, cascadeId => {\n                    let cascadePayload = cascadeProp;\n\n                    if (_.isFunction(cascadeProp)) {\n                      const cascadeData = { ..._.get(state, `${path}.${cascadeId}`)\n                      };\n                      const boundNode = { ...boundNodes[cascadeId]\n                      };\n                      cascadePayload = cascadeProp(payload, updatedData, updatedNode, cascadeData, boundNode);\n                    }\n\n                    if (cascadePayload !== null) {\n                      cascadePayload.id = cascadeId;\n                      store.dispatch({\n                        payload: cascadePayload,\n                        type: boundActionType\n                      });\n                    }\n                  });\n                }\n              }\n\n              store.dispatch({\n                payload: dataPayload,\n                type: boundActionType\n              });\n            } else if (type === DELETE_NODE) {\n              let deleteId = dataPayload.id;\n\n              if (!_.isArray(deleteId)) {\n                deleteId = [deleteId];\n              }\n\n              let allIds = [];\n\n              _.forEach(deleteId, dId => {\n                allIds = allIds.concat([dId, ...getAllDescendantIds(state.hierarchy.nodes[path], dId)]);\n              });\n\n              dataPayload.id = allIds;\n              store.dispatch({\n                payload: dataPayload,\n                type: boundActionType\n              });\n            } else {\n              store.dispatch({\n                payload: dataPayload,\n                type: boundActionType\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if ([CREATE_NODE, DELETE_NODE, UPDATE_NODE, CLEAR_NODES].includes(action.type) && nodePayload) {\n    action.payload = nodePayload;\n  }\n\n  return next(action);\n};\nexport const bindNodes = (store, path, createAction, updateAction, deleteAction, clearAction, options) => {\n  store.dispatch(setBinding({\n    clearAction,\n    createAction,\n    deleteAction,\n    options,\n    path,\n    updateAction\n  }));\n};\nexport const createNodeDataSelector = path => {\n  return createSelector(state => _.at(state, path)[0], state => _.at(state.hierarchy.nodes, path)[0], (data, nodes) => {\n    const combined = {};\n\n    _.forEach(nodes, node => {\n      combined[node.id] = { ...node,\n        ...data[node.id]\n      };\n    });\n\n    return combined;\n  });\n};\nexport const createOrderedNodeDataSelector = path => {\n  const nodeDataSelector = createNodeDataSelector(path);\n  return createSelector(nodeDataSelector, nodeData => {\n    const orderedNodeIds = orderedNodeList(nodeData.root.children, nodeData);\n    const orderedNodes = [];\n\n    _.forEach(orderedNodeIds, (id, index) => {\n      const node = nodeData[id];\n      orderedNodes.push({ ...node,\n        parent: nodeData[node.parent],\n        descendants: getAllDescendantIds(nodeData, node.id),\n        ancestors: getParentIds(nodeData, node.id),\n        left: nodeData[orderedNodeIds[index - 1]],\n        right: nodeData[orderedNodeIds[index + 1]]\n      });\n    });\n\n    return orderedNodes;\n  });\n};\nexport { getAllDescendantIds, getDescendantIds, getAllChildIds, getAllSiblingIds, getLeftSiblingId, getLeftSiblingIds, getRightSiblingId, getRightSiblingIds, getParentIds, getParentId, createNode, updateNode, deleteNode, clearNodes, moveNode, moveNodeUp, moveNodeDown, indentNode, unindentNode };","map":{"version":3,"sources":["/Users/gkweston/Git/todo-436/src/store/hierarchy/index.js"],"names":["_","combineReducers","createSelector","binding","setBinding","nodes","getAllDescendantIds","getDescendantIds","getAllChildIds","getAllSiblingIds","getLeftSiblingId","getLeftSiblingIds","getRightSiblingId","getRightSiblingIds","getParentIds","getParentId","getIndexes","orderedNodeList","createNode","updateNode","deleteNode","clearNodes","moveNode","moveNodeUp","moveNodeDown","indentNode","unindentNode","types","CREATE_NODE","DELETE_NODE","UPDATE_NODE","CLEAR_NODES","CREATE_NODE_PATH","MOVE_NODE","MOVE_NODE_DOWN","MOVE_NODE_UP","INDENT_NODE","UNINDENT_NODE","BINDING_SET","combined","getBinding","state","action","size","Object","values","includes","type","path","hierarchy","payload","newState","bound","googleStyle","forEach","data","dataPath","indexing","pick","length","hierarchyMiddleware","store","next","nodePayload","getState","bindings","undefined","id","uniqueId","isArray","value","index","toString","dataPayload","omit","boundActionType","createAction","deleteAction","updateAction","clearAction","cascadeLength","cascade","cascadeProp","boundNodes","ids","dir","updatedData","updatedNode","isFunction","get","cascadeId","cascadePayload","cascadeData","boundNode","dispatch","deleteId","allIds","dId","concat","bindNodes","options","createNodeDataSelector","at","node","createOrderedNodeDataSelector","nodeDataSelector","nodeData","orderedNodeIds","root","children","orderedNodes","push","parent","descendants","ancestors","left","right"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport { combineReducers } from 'redux';\nimport { createSelector } from 'reselect';\nimport binding, { setBinding } from './binding';\nimport nodes from './nodes';\nimport {\n  getAllDescendantIds,\n  getDescendantIds,\n  getAllChildIds,\n  getAllSiblingIds,\n  getLeftSiblingId,\n  getLeftSiblingIds,\n  getRightSiblingId,\n  getRightSiblingIds,\n  getParentIds,\n  getParentId,\n  getIndexes,\n  orderedNodeList\n} from './nodes/helpers';\n\nimport {\n  createNode,\n  updateNode,\n  deleteNode,\n  clearNodes,\n  moveNode,\n  moveNodeUp,\n  moveNodeDown,\n  indentNode,\n  unindentNode\n} from './nodes';\n\nimport { types } from './nodes/types';\n\nconst {\n  CREATE_NODE,\n  DELETE_NODE,\n  UPDATE_NODE,\n  CLEAR_NODES,\n  CREATE_NODE_PATH,\n  MOVE_NODE,\n  MOVE_NODE_DOWN,\n  MOVE_NODE_UP,\n  INDENT_NODE,\n  UNINDENT_NODE\n} = types;\n\nconst BINDING_SET = 'HIERARCHY/BINDING/SET';\n\nconst combined = combineReducers({\n  binding,\n  nodes\n});\n\nconst getBinding = (state, action) => {\n  if (state.binding && _.size(state.binding)) {\n    if (Object.values(types).includes(action.type) && action.path) {\n      return state.binding[action.path];\n    }\n  }\n\n  return false;\n};\n\nexport const hierarchy = (state = {}, action) => {\n  const { path, type, payload } = action;\n  const newState = combined(state, action);\n\n  if (action.type === BINDING_SET) {\n    return combined(newState, {\n      path: payload.path,\n      type: CREATE_NODE_PATH\n    });\n  }\n\n  if (type === UNINDENT_NODE) {\n    const bound = getBinding(state, action);\n    if (bound) {\n      payload.googleStyle = bound.googleStyle;\n    }\n  }\n\n  if (newState.binding && _.size(newState.binding) && _.size(newState.nodes)) {\n    _.forEach(newState.binding, (data, dataPath) => {\n      if (data.indexing && dataPath === path) {\n        if (newState.nodes[dataPath] && _.size(newState.nodes[dataPath])) {\n          if (\n            [\n              CREATE_NODE,\n              DELETE_NODE,\n              MOVE_NODE,\n              MOVE_NODE_DOWN,\n              MOVE_NODE_UP,\n              INDENT_NODE,\n              UNINDENT_NODE\n            ].includes(type) ||\n            (type === UPDATE_NODE &&\n              action.payload &&\n              _.pick(action.payload, [\n                'parent',\n                'at',\n                'first',\n                'before',\n                'after'\n              ]).length)\n          ) {\n            newState.nodes[dataPath] = getIndexes(newState.nodes[dataPath]);\n          }\n        }\n      }\n    });\n  }\n\n  return newState;\n};\n\nexport const hierarchyMiddleware = store => next => action => {\n  let nodePayload;\n\n  if (\n    [CREATE_NODE, DELETE_NODE, UPDATE_NODE, CLEAR_NODES].includes(action.type)\n  ) {\n    const state = store.getState();\n    if (state.hierarchy) {\n      const bindings = state.hierarchy.binding;\n\n      const { type, path } = action;\n      let { payload } = action;\n\n      if (bindings && path) {\n        const bound = bindings[path];\n        if (bound) {\n          if (type !== CLEAR_NODES) {\n            if (type === CREATE_NODE && payload === undefined) {\n              payload = {};\n            }\n\n            if (payload.id === undefined) {\n              payload.id = _.uniqueId();\n            } else if (_.isArray(payload.id)) {\n              _.forEach(payload.id, (value, index) => {\n                payload.id[index] = _.toString(value);\n              });\n            } else {\n              payload.id = _.toString(payload.id);\n            }\n          }\n\n          nodePayload = _.pick(payload, [\n            'id',\n            'parent',\n            'at',\n            'first',\n            'before',\n            'after'\n          ]);\n          const dataPayload = _.omit(payload, [\n            'parent',\n            'at',\n            'first',\n            'before',\n            'after',\n            'afterIndex',\n            'cascade',\n            'cascadeProp',\n            'cascadeLength'\n          ]);\n\n          let boundActionType;\n          switch (type) {\n            case CREATE_NODE:\n              boundActionType = bound.createAction;\n              break;\n            case DELETE_NODE:\n              boundActionType = bound.deleteAction;\n              break;\n            case UPDATE_NODE:\n              boundActionType = bound.updateAction;\n              break;\n            case CLEAR_NODES:\n              boundActionType = bound.clearAction;\n              break;\n            default: {\n              boundActionType = undefined;\n            }\n          }\n          if (boundActionType) {\n            if (type === UPDATE_NODE) {\n              const { cascadeLength } = payload;\n              let { cascade, cascadeProp } = payload;\n\n              if (cascade) {\n                const boundNodes = state.hierarchy.nodes[path];\n\n                if (cascadeProp === undefined) {\n                  cascadeProp = _.omit(dataPayload, ['id']);\n                } else if (_.isArray(cascadeProp)) {\n                  cascadeProp = _.omit(_.pick(dataPayload, cascadeProp), [\n                    'id'\n                  ]);\n                }\n\n                let ids = [];\n\n                if (!_.isArray(cascade)) {\n                  cascade = [cascade];\n                }\n\n                _.forEach(cascade, dir => {\n                  if (\n                    ['left', 'right', 'up', 'down'].includes(dir) &&\n                    cascadeLength\n                  ) {\n                    switch (dir) {\n                      case 'left': {\n                        ids = [\n                          ...ids,\n                          ...getLeftSiblingIds(\n                            boundNodes,\n                            payload.id,\n                            cascadeLength\n                          )\n                        ];\n                        break;\n                      }\n                      case 'right': {\n                        ids = [\n                          ...ids,\n                          ...getRightSiblingIds(\n                            boundNodes,\n                            payload.id,\n                            cascadeLength\n                          )\n                        ];\n                        break;\n                      }\n                      case 'up': {\n                        ids = [\n                          ...ids,\n                          ...getParentIds(boundNodes, payload.id, cascadeLength)\n                        ];\n                        break;\n                      }\n                      case 'down': {\n                        ids = [\n                          ...ids,\n                          ...getDescendantIds(\n                            boundNodes,\n                            payload.id,\n                            cascadeLength\n                          )\n                        ];\n                        break;\n                      }\n                      default: {\n                        ids = [];\n                      }\n                    }\n                  } else if (\n                    [\n                      'root',\n                      'parent',\n                      'children',\n                      'descendants',\n                      'siblings',\n                      'leftSiblings',\n                      'rightSiblings',\n                      'leftSibling',\n                      'rightSibling'\n                    ].includes(dir)\n                  ) {\n                    switch (dir) {\n                      case 'root': {\n                        ids = [...ids, ...getParentIds(boundNodes, payload.id)];\n                        break;\n                      }\n                      case 'parent': {\n                        ids = [...ids, getParentId(boundNodes, payload.id)];\n                        break;\n                      }\n                      case 'children': {\n                        ids = [\n                          ...ids,\n                          ...getAllChildIds(boundNodes, payload.id)\n                        ];\n                        break;\n                      }\n                      case 'descendants': {\n                        ids = [\n                          ...ids,\n                          ...getAllDescendantIds(boundNodes, payload.id)\n                        ];\n                        break;\n                      }\n                      case 'siblings': {\n                        ids = [\n                          ...ids,\n                          ...getAllSiblingIds(boundNodes, payload.id)\n                        ];\n                        break;\n                      }\n                      case 'leftSiblings': {\n                        ids = [\n                          ...ids,\n                          ...getLeftSiblingIds(boundNodes, payload.id)\n                        ];\n                        break;\n                      }\n                      case 'rightSiblings': {\n                        ids = [\n                          ...ids,\n                          ...getRightSiblingIds(boundNodes, payload.id)\n                        ];\n                        break;\n                      }\n                      case 'leftSibling': {\n                        ids = [\n                          ...ids,\n                          getLeftSiblingId(boundNodes, payload.id)\n                        ];\n                        break;\n                      }\n                      case 'rightSibling': {\n                        ids = [\n                          ...ids,\n                          getRightSiblingId(boundNodes, payload.id)\n                        ];\n                        break;\n                      }\n                      default: {\n                        ids = [];\n                      }\n                    }\n                  }\n                });\n\n                if (ids.length) {\n                  let updatedData;\n                  let updatedNode;\n\n                  if (_.isFunction(cascadeProp)) {\n                    updatedNode = { ...boundNodes[payload.id] };\n                    updatedData = { ..._.get(state, `${path}.${payload.id}`) };\n                  }\n\n                  _.forEach(ids, cascadeId => {\n                    let cascadePayload = cascadeProp;\n\n                    if (_.isFunction(cascadeProp)) {\n                      const cascadeData = {\n                        ..._.get(state, `${path}.${cascadeId}`)\n                      };\n                      const boundNode = { ...boundNodes[cascadeId] };\n                      cascadePayload = cascadeProp(\n                        payload,\n                        updatedData,\n                        updatedNode,\n                        cascadeData,\n                        boundNode\n                      );\n                    }\n\n                    if (cascadePayload !== null) {\n                      cascadePayload.id = cascadeId;\n\n                      store.dispatch({\n                        payload: cascadePayload,\n                        type: boundActionType\n                      });\n                    }\n                  });\n                }\n              }\n\n              store.dispatch({ payload: dataPayload, type: boundActionType });\n            } else if (type === DELETE_NODE) {\n              let deleteId = dataPayload.id;\n\n              if (!_.isArray(deleteId)) {\n                deleteId = [deleteId];\n              }\n\n              let allIds = [];\n\n              _.forEach(deleteId, dId => {\n                allIds = allIds.concat([\n                  dId,\n                  ...getAllDescendantIds(state.hierarchy.nodes[path], dId)\n                ]);\n              });\n\n              dataPayload.id = allIds;\n\n              store.dispatch({ payload: dataPayload, type: boundActionType });\n            } else {\n              store.dispatch({ payload: dataPayload, type: boundActionType });\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (\n    [CREATE_NODE, DELETE_NODE, UPDATE_NODE, CLEAR_NODES].includes(\n      action.type\n    ) &&\n    nodePayload\n  ) {\n    action.payload = nodePayload;\n  }\n\n  return next(action);\n};\n\nexport const bindNodes = (\n  store,\n  path,\n  createAction,\n  updateAction,\n  deleteAction,\n  clearAction,\n  options\n) => {\n  store.dispatch(\n    setBinding({\n      clearAction,\n      createAction,\n      deleteAction,\n      options,\n      path,\n      updateAction\n    })\n  );\n};\n\nexport const createNodeDataSelector = path => {\n  return createSelector(\n    state => _.at(state, path)[0],\n    state => _.at(state.hierarchy.nodes, path)[0],\n    (data, nodes) => {\n      const combined = {};\n\n      _.forEach(nodes, node => {\n        combined[node.id] = {\n          ...node,\n          ...data[node.id]\n        };\n      });\n\n      return combined;\n    }\n  );\n};\n\nexport const createOrderedNodeDataSelector = path => {\n  const nodeDataSelector = createNodeDataSelector(path);\n  return createSelector(\n    nodeDataSelector,\n    nodeData => {\n      const orderedNodeIds = orderedNodeList(nodeData.root.children, nodeData);\n\n      const orderedNodes = [];\n\n      _.forEach(orderedNodeIds, (id, index) => {\n        const node = nodeData[id];\n\n        orderedNodes.push({\n          ...node,\n          parent: nodeData[node.parent],\n          descendants: getAllDescendantIds(nodeData, node.id),\n          ancestors: getParentIds(nodeData, node.id),\n          left: nodeData[orderedNodeIds[index - 1]],\n          right: nodeData[orderedNodeIds[index + 1]]\n        });\n      });\n\n      return orderedNodes;\n    }\n  );\n};\n\nexport {\n  getAllDescendantIds,\n  getDescendantIds,\n  getAllChildIds,\n  getAllSiblingIds,\n  getLeftSiblingId,\n  getLeftSiblingIds,\n  getRightSiblingId,\n  getRightSiblingIds,\n  getParentIds,\n  getParentId,\n  createNode,\n  updateNode,\n  deleteNode,\n  clearNodes,\n  moveNode,\n  moveNodeUp,\n  moveNodeDown,\n  indentNode,\n  unindentNode\n};\n"]},"metadata":{},"sourceType":"module"}
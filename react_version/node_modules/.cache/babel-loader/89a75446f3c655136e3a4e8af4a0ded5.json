{"ast":null,"code":"import { ADD_CHILD, REMOVE_CHILD, ORDER_CHILD } from './types';\nexport default (function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  let {\n    type\n  } = action;\n  let {\n    id,\n    at,\n    first,\n    before,\n    after\n  } = action.payload;\n  id = id.toString();\n  before = before ? before.toString() : before;\n  after = after ? after.toString() : after;\n\n  if (id === undefined) {\n    return state;\n  }\n\n  if (type === ORDER_CHILD) {\n    type = ADD_CHILD;\n    state = state.filter(child => child !== id);\n  }\n\n  switch (type) {\n    case ADD_CHILD:\n      {\n        if (first === true) {\n          return [id, ...state];\n        }\n\n        if (at !== undefined) {\n          if (at <= 0) {\n            return [id, ...state];\n          } else if (at >= state.length) {\n            return [...state, id];\n          }\n\n          return [...state.slice(0, at), id, ...state.slice(at)];\n        }\n\n        if (before !== undefined) {\n          if (state[0] === before) {\n            return [id, ...state];\n          }\n\n          const beforeIndex = state.findIndex(child => child === before);\n          return [...state.slice(0, beforeIndex), id, ...state.slice(beforeIndex)];\n        }\n\n        if (after !== undefined) {\n          if (state[state.length - 1] === after) {\n            return [...state, id];\n          }\n\n          const afterIndex = state.findIndex(child => child === after) + 1;\n          return [...state.slice(0, afterIndex), id, ...state.slice(afterIndex)];\n        }\n\n        return [...state, id];\n      }\n\n    case REMOVE_CHILD:\n      return state.filter(child => child !== id);\n\n    default:\n      return state;\n  }\n});","map":{"version":3,"sources":["/Users/gkweston/Git/todo-436/src/store/hierarchy/nodes/children.js"],"names":["ADD_CHILD","REMOVE_CHILD","ORDER_CHILD","state","action","type","id","at","first","before","after","payload","toString","undefined","filter","child","length","slice","beforeIndex","findIndex","afterIndex"],"mappings":"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","sourcesContent":["import { ADD_CHILD, REMOVE_CHILD, ORDER_CHILD } from './types';\n\nexport default (state = [], action) => {\n  let { type } = action;\n  let { id, at, first, before, after } = action.payload;\n\n  id = id.toString();\n  before = before ? before.toString() : before;\n  after = after ? after.toString() : after;\n\n  if (id === undefined) {\n    return state;\n  }\n\n  if (type === ORDER_CHILD) {\n    type = ADD_CHILD;\n    state = state.filter(child => child !== id);\n  }\n\n  switch (type) {\n    case ADD_CHILD: {\n      if (first === true) {\n        return [id, ...state];\n      }\n\n      if (at !== undefined) {\n        if (at <= 0) {\n          return [id, ...state];\n        } else if (at >= state.length) {\n          return [...state, id];\n        }\n\n        return [...state.slice(0, at), id, ...state.slice(at)];\n      }\n\n      if (before !== undefined) {\n        if (state[0] === before) {\n          return [id, ...state];\n        }\n        const beforeIndex = state.findIndex(child => child === before);\n\n        return [\n          ...state.slice(0, beforeIndex),\n          id,\n          ...state.slice(beforeIndex)\n        ];\n      }\n\n      if (after !== undefined) {\n        if (state[state.length - 1] === after) {\n          return [...state, id];\n        }\n\n        const afterIndex = state.findIndex(child => child === after) + 1;\n\n        return [...state.slice(0, afterIndex), id, ...state.slice(afterIndex)];\n      }\n\n      return [...state, id];\n    }\n\n    case REMOVE_CHILD:\n      return state.filter(child => child !== id);\n    default:\n      return state;\n  }\n};\n"]},"metadata":{},"sourceType":"module"}
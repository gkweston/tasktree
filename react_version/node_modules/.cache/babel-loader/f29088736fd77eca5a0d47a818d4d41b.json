{"ast":null,"code":"import _ from 'lodash';\nimport children from './children';\nimport { getAllDescendantIds, deleteMany, getLeftSiblingId, getRightSiblingId, reducerMoveNode, getRightSiblingIds } from './helpers';\nimport { ADD_CHILD, CLEAR_NODES, CREATE_NODE, DELETE_NODE, INDENT_NODE, MOVE_NODE, MOVE_NODE_DOWN, MOVE_NODE_UP, REMOVE_CHILD, UNINDENT_NODE, UPDATE_NODE } from './types';\nexport default (function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  const {\n    type\n  } = action;\n  const {\n    payload\n  } = action;\n\n  if (type === CLEAR_NODES) {\n    return {\n      root: {\n        children: [],\n        depth: -1,\n        id: 'root',\n        parent: undefined\n      }\n    };\n  }\n\n  if (payload === undefined || payload.id === undefined) {\n    return state;\n  }\n\n  let {\n    id,\n    parent\n  } = payload;\n  id = id.toString();\n\n  if (parent) {\n    parent = parent.toString();\n  }\n\n  switch (type) {\n    case UPDATE_NODE:\n    case MOVE_NODE:\n      {\n        return reducerMoveNode(state, payload);\n      }\n\n    case MOVE_NODE_DOWN:\n      {\n        const sibling = getRightSiblingId(state, id);\n\n        if (sibling && state[sibling].id !== 'root') {\n          return reducerMoveNode(state, {\n            after: sibling,\n            id\n          });\n        }\n\n        return state;\n      }\n\n    case MOVE_NODE_UP:\n      {\n        const sibling = getLeftSiblingId(state, id);\n\n        if (sibling && state[sibling].id !== 'root') {\n          return reducerMoveNode(state, {\n            before: sibling,\n            id\n          });\n        }\n\n        return state;\n      }\n\n    case INDENT_NODE:\n      {\n        const sibling = getLeftSiblingId(state, id);\n\n        if (sibling && state[sibling].id !== 'root') {\n          return reducerMoveNode(state, {\n            id,\n            parent: sibling\n          });\n        }\n\n        return state;\n      }\n\n    case UNINDENT_NODE:\n      {\n        const parentId = parent || state[id].parent;\n\n        if (parentId === 'root' || state[parentId] === undefined) {\n          return state;\n        }\n\n        const newSibling = parentId;\n        const parentParentId = state[parentId].parent;\n\n        if (parentParentId) {\n          let newState = reducerMoveNode(state, {\n            after: newSibling,\n            id,\n            parent: parentParentId\n          });\n\n          if (payload.googleStyle) {\n            const rightSiblings = getRightSiblingIds(state, id);\n\n            _.forEach(rightSiblings, nodeId => {\n              newState = reducerMoveNode(newState, {\n                id: nodeId,\n                parent: id\n              });\n            });\n          }\n\n          return newState;\n        }\n\n        return state;\n      }\n\n    case CREATE_NODE:\n      {\n        const parentId = parent || 'root';\n\n        if (state[parentId] === undefined) {\n          return state;\n        }\n\n        const newNode = {\n          children: [],\n          depth: parentId === 'root' ? 0 : state[parentId].depth + 1,\n          id,\n          parent: parentId\n        };\n        return { ...state,\n          [id]: newNode,\n          [parentId]: { ...state[parentId],\n            children: children(state[parentId].children, {\n              payload,\n              type: ADD_CHILD\n            })\n          }\n        };\n      }\n\n    case DELETE_NODE:\n      {\n        let idArr = id;\n\n        if (!_.isArray(id)) {\n          idArr = [id];\n        }\n\n        let newState = { ...state\n        };\n\n        _.forEach(idArr, childId => {\n          const parentId = state[childId].parent;\n          const descendantIds = getAllDescendantIds(newState, childId);\n          newState = { ...deleteMany(newState, [childId, ...descendantIds]),\n            [parentId]: { ...newState[parentId],\n              children: children(newState[parentId].children, {\n                payload: {\n                  id: childId\n                },\n                type: REMOVE_CHILD\n              })\n            }\n          };\n        });\n\n        return newState;\n      }\n\n    default:\n      {\n        return state;\n      }\n  }\n});","map":{"version":3,"sources":["/Users/gkweston/Git/todo-436/src/store/hierarchy/nodes/nodes.js"],"names":["_","children","getAllDescendantIds","deleteMany","getLeftSiblingId","getRightSiblingId","reducerMoveNode","getRightSiblingIds","ADD_CHILD","CLEAR_NODES","CREATE_NODE","DELETE_NODE","INDENT_NODE","MOVE_NODE","MOVE_NODE_DOWN","MOVE_NODE_UP","REMOVE_CHILD","UNINDENT_NODE","UPDATE_NODE","state","action","type","payload","root","depth","id","parent","undefined","toString","sibling","after","before","parentId","newSibling","parentParentId","newState","googleStyle","rightSiblings","forEach","nodeId","newNode","idArr","isArray","childId","descendantIds"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport children from './children';\nimport {\n  getAllDescendantIds,\n  deleteMany,\n  getLeftSiblingId,\n  getRightSiblingId,\n  reducerMoveNode,\n  getRightSiblingIds\n} from './helpers';\n\nimport {\n  ADD_CHILD,\n  CLEAR_NODES,\n  CREATE_NODE,\n  DELETE_NODE,\n  INDENT_NODE,\n  MOVE_NODE,\n  MOVE_NODE_DOWN,\n  MOVE_NODE_UP,\n  REMOVE_CHILD,\n  UNINDENT_NODE,\n  UPDATE_NODE\n} from './types';\n\nexport default (state = {}, action) => {\n  const { type } = action;\n  const { payload } = action;\n\n  if (type === CLEAR_NODES) {\n    return {\n      root: {\n        children: [],\n        depth: -1,\n        id: 'root',\n        parent: undefined\n      }\n    };\n  }\n\n  if (payload === undefined || payload.id === undefined) {\n    return state;\n  }\n\n  let { id, parent } = payload;\n\n  id = id.toString();\n  if (parent) {\n    parent = parent.toString();\n  }\n\n  switch (type) {\n    case UPDATE_NODE:\n    case MOVE_NODE: {\n      return reducerMoveNode(state, payload);\n    }\n    case MOVE_NODE_DOWN: {\n      const sibling = getRightSiblingId(state, id);\n      if (sibling && state[sibling].id !== 'root') {\n        return reducerMoveNode(state, {\n          after: sibling,\n          id\n        });\n      }\n      return state;\n    }\n    case MOVE_NODE_UP: {\n      const sibling = getLeftSiblingId(state, id);\n      if (sibling && state[sibling].id !== 'root') {\n        return reducerMoveNode(state, {\n          before: sibling,\n          id\n        });\n      }\n      return state;\n    }\n    case INDENT_NODE: {\n      const sibling = getLeftSiblingId(state, id);\n      if (sibling && state[sibling].id !== 'root') {\n        return reducerMoveNode(state, {\n          id,\n          parent: sibling\n        });\n      }\n\n      return state;\n    }\n    case UNINDENT_NODE: {\n      const parentId = parent || state[id].parent;\n\n      if (parentId === 'root' || state[parentId] === undefined) {\n        return state;\n      }\n\n      const newSibling = parentId;\n      const parentParentId = state[parentId].parent;\n\n      if (parentParentId) {\n        let newState = reducerMoveNode(state, {\n          after: newSibling,\n          id,\n          parent: parentParentId\n        });\n\n        if (payload.googleStyle) {\n          const rightSiblings = getRightSiblingIds(state, id);\n          _.forEach(rightSiblings, nodeId => {\n            newState = reducerMoveNode(newState, {\n              id: nodeId,\n              parent: id\n            });\n          });\n        }\n        return newState;\n      }\n\n      return state;\n    }\n    case CREATE_NODE: {\n      const parentId = parent || 'root';\n\n      if (state[parentId] === undefined) {\n        return state;\n      }\n\n      const newNode = {\n        children: [],\n        depth: parentId === 'root' ? 0 : state[parentId].depth + 1,\n        id,\n        parent: parentId\n      };\n\n      return {\n        ...state,\n        [id]: newNode,\n        [parentId]: {\n          ...state[parentId],\n          children: children(state[parentId].children, {\n            payload,\n            type: ADD_CHILD\n          })\n        }\n      };\n    }\n    case DELETE_NODE: {\n      let idArr = id;\n      if (!_.isArray(id)) {\n        idArr = [id];\n      }\n\n      let newState = { ...state };\n\n      _.forEach(idArr, childId => {\n        const parentId = state[childId].parent;\n        const descendantIds = getAllDescendantIds(newState, childId);\n\n        newState = {\n          ...deleteMany(newState, [childId, ...descendantIds]),\n          [parentId]: {\n            ...newState[parentId],\n            children: children(newState[parentId].children, {\n              payload: {\n                id: childId\n              },\n              type: REMOVE_CHILD\n            })\n          }\n        };\n      });\n\n      return newState;\n    }\n    default: {\n      return state;\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _ from 'lodash';\nimport children from './children';\nimport { REMOVE_CHILD, ORDER_CHILD } from './types';\nexport const orderedNodeList = (rootIds, allNodes, o) => {\n  let ordered = o || [];\n\n  _.forEach(rootIds, id => {\n    ordered.push(id);\n\n    if (allNodes[id].children.length) {\n      ordered = orderedNodeList(allNodes[id].children, allNodes, ordered);\n    }\n  });\n\n  return ordered;\n};\nexport const getAllDescendantIds = (state, id) => state[id].children.reduce((acc, childId) => [...acc, childId, ...getAllDescendantIds(state, childId)], []);\nexport const deleteMany = (state, ids) => {\n  const newState = { ...state\n  };\n  ids.forEach(descendant => {\n    delete newState[descendant];\n  });\n  return newState;\n};\n\nconst getDescIds = function (state, id, depth, nodeDepth) {\n  let depthAt = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  const newDepth = state[id].depth;\n\n  if (newDepth !== nodeDepth) {\n    depthAt += 1;\n  }\n\n  if (depthAt >= depth) {\n    return state[id].children;\n  }\n\n  return state[id].children.reduce((acc, childId) => [...acc, childId, ...getDescIds(state, childId, depth, newDepth, depthAt)], []);\n};\n\nexport const getDescendantIds = function (state, id) {\n  let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n  let depthAt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  if (depth <= 0) {\n    return getAllDescendantIds(state, id);\n  }\n\n  depth -= 1;\n  const nodeDepth = state[id].depth;\n  return getDescIds(state, id, depth, nodeDepth, depthAt);\n};\nexport const getAllChildIds = (state, id) => state[id].children;\nexport const getParentId = (state, id) => state[id].parent;\nexport const getAllSiblingIds = (state, id) => {\n  const parentId = getParentId(state, id);\n  return state[parentId].children;\n};\nexport const getLeftSiblingIds = function (state, id) {\n  let length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n  const parentId = getParentId(state, id);\n  const index = state[parentId].children.indexOf(id);\n  let leftSiblings = state[parentId].children.slice(0, index);\n\n  if (length === -1) {\n    return leftSiblings;\n  }\n\n  if (length > leftSiblings.length) {\n    length = leftSiblings.length;\n  }\n\n  leftSiblings = _.reverse(leftSiblings);\n  leftSiblings.length = length;\n  return _.reverse(leftSiblings);\n};\nexport const getLeftSiblingId = (state, id) => {\n  const ids = getLeftSiblingIds(state, id, 1);\n\n  if (ids.length) {\n    return ids[0];\n  }\n\n  return undefined;\n};\nexport const getRightSiblingIds = function (state, id) {\n  let length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n  const parentId = getParentId(state, id);\n  const index = state[parentId].children.indexOf(id) + 1;\n  const rightSiblings = state[parentId].children.slice(index);\n\n  if (length === -1) {\n    return rightSiblings;\n  }\n\n  if (length > rightSiblings.length) {\n    length = rightSiblings.length;\n  }\n\n  rightSiblings.length = length;\n  return rightSiblings;\n};\nexport const getRightSiblingId = (state, id) => {\n  const ids = getRightSiblingIds(state, id, 1);\n\n  if (ids.length) {\n    return ids[0];\n  }\n\n  return undefined;\n};\nexport const getParentIds = function (state, id) {\n  let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n  let currentId = getParentId(state, id);\n\n  if (currentId === 'root') {\n    return [];\n  }\n\n  const parentIds = [];\n  let depthAt = 0;\n\n  while (currentId !== 'root') {\n    if (depth >= 0 && depthAt >= depth) {\n      break;\n    }\n\n    depthAt += 1;\n    parentIds.push(currentId);\n    currentId = getParentId(state, currentId);\n  }\n\n  return parentIds;\n};\nlet count = 0;\n\nconst getIndexesRecurse = (node, indexes, state) => {\n  if (node.children.length > 0) {\n    _.forEach(node.children, childId => {\n      if (indexes[childId] === undefined) {\n        indexes[childId] = count;\n        state[childId] = { ...state[childId],\n          index: count\n        };\n        count += 1;\n      }\n\n      if (state[childId].children) {\n        indexes = getIndexesRecurse(state[childId], indexes, state);\n      }\n    });\n  }\n\n  if (indexes[node.id] === undefined) {\n    indexes[node.id] = count;\n    state[node.id] = { ...state[node.id],\n      index: count\n    };\n    count += 1;\n  }\n\n  return indexes;\n};\n\nexport const getIndexes = nodes => {\n  const newNodes = { ...nodes\n  };\n  count = 0;\n  getIndexesRecurse(newNodes.root, {}, newNodes);\n  newNodes.root = { ...newNodes.root,\n    index: -1\n  };\n  return newNodes;\n};\nexport const reducerMoveNode = (state, payload) => {\n  if (payload.afterIndex !== undefined) {\n    const indexNode = _.find(state, n => n.id === payload.afterIndex);\n\n    if (indexNode.children.length && payload.makeChild) {\n      payload.first = true;\n      payload.parent = indexNode.id;\n    } else {\n      payload.after = indexNode.id;\n      payload.parent = indexNode.parent;\n    }\n  }\n\n  const {\n    id,\n    parent\n  } = payload;\n  const parentId = parent || state[id].parent;\n  const oldParent = state[id].parent;\n\n  if (oldParent !== parentId) {\n    const updatedChildren = {};\n    const oldDepth = state[id].depth;\n    const newDepth = parentId === 'root' ? 0 : state[parentId].depth + 1;\n    const depthDiff = newDepth - oldDepth;\n\n    if (depthDiff !== 0 && state[id].children.length) {\n      const descendants = getAllDescendantIds(state, id);\n\n      _.forEach(descendants, childId => {\n        updatedChildren[childId] = Object.assign({}, state[childId], {\n          depth: state[childId].depth + depthDiff\n        });\n      });\n    }\n\n    return { ...state,\n      ...updatedChildren,\n      [id]: { ...state[id],\n        depth: newDepth,\n        parent: parentId\n      },\n      [oldParent]: { ...state[oldParent],\n        children: children(state[oldParent].children, {\n          payload,\n          type: REMOVE_CHILD\n        })\n      },\n      [parentId]: { ...state[parentId],\n        children: children(state[parentId].children, {\n          payload,\n          type: ORDER_CHILD\n        })\n      }\n    };\n  }\n\n  return { ...state,\n    [parentId]: { ...state[parentId],\n      children: children(state[parentId].children, {\n        payload,\n        type: ORDER_CHILD\n      })\n    }\n  };\n};\nexport const getPathPayloadAction = type => {\n  const act = (path, payload) => ({\n    path,\n    payload,\n    type\n  });\n\n  return act;\n};","map":{"version":3,"sources":["/Users/gkweston/Git/todo-436/src/store/hierarchy/nodes/helpers.js"],"names":["_","children","REMOVE_CHILD","ORDER_CHILD","orderedNodeList","rootIds","allNodes","o","ordered","forEach","id","push","length","getAllDescendantIds","state","reduce","acc","childId","deleteMany","ids","newState","descendant","getDescIds","depth","nodeDepth","depthAt","newDepth","getDescendantIds","getAllChildIds","getParentId","parent","getAllSiblingIds","parentId","getLeftSiblingIds","index","indexOf","leftSiblings","slice","reverse","getLeftSiblingId","undefined","getRightSiblingIds","rightSiblings","getRightSiblingId","getParentIds","currentId","parentIds","count","getIndexesRecurse","node","indexes","getIndexes","nodes","newNodes","root","reducerMoveNode","payload","afterIndex","indexNode","find","n","makeChild","first","after","oldParent","updatedChildren","oldDepth","depthDiff","descendants","Object","assign","type","getPathPayloadAction","act","path"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport children from './children';\nimport { REMOVE_CHILD, ORDER_CHILD } from './types';\n\nexport const orderedNodeList = (rootIds, allNodes, o) => {\n  let ordered = o || [];\n\n  _.forEach(rootIds, id => {\n    ordered.push(id);\n    if (allNodes[id].children.length) {\n      ordered = orderedNodeList(allNodes[id].children, allNodes, ordered);\n    }\n  });\n\n  return ordered;\n};\n\nexport const getAllDescendantIds = (state, id) =>\n  state[id].children.reduce(\n    (acc, childId) => [...acc, childId, ...getAllDescendantIds(state, childId)],\n    []\n  );\n\nexport const deleteMany = (state, ids) => {\n  const newState = { ...state };\n\n  ids.forEach(descendant => {\n    delete newState[descendant];\n  });\n  return newState;\n};\n\nconst getDescIds = (state, id, depth, nodeDepth, depthAt = 0) => {\n  const newDepth = state[id].depth;\n  if (newDepth !== nodeDepth) {\n    depthAt += 1;\n  }\n\n  if (depthAt >= depth) {\n    return state[id].children;\n  }\n\n  return state[id].children.reduce(\n    (acc, childId) => [\n      ...acc,\n      childId,\n      ...getDescIds(state, childId, depth, newDepth, depthAt)\n    ],\n    []\n  );\n};\n\nexport const getDescendantIds = (state, id, depth = -1, depthAt = 0) => {\n  if (depth <= 0) {\n    return getAllDescendantIds(state, id);\n  }\n\n  depth -= 1;\n  const nodeDepth = state[id].depth;\n\n  return getDescIds(state, id, depth, nodeDepth, depthAt);\n};\n\nexport const getAllChildIds = (state, id) => state[id].children;\n\nexport const getParentId = (state, id) => state[id].parent;\n\nexport const getAllSiblingIds = (state, id) => {\n  const parentId = getParentId(state, id);\n  return state[parentId].children;\n};\n\nexport const getLeftSiblingIds = (state, id, length = -1) => {\n  const parentId = getParentId(state, id);\n  const index = state[parentId].children.indexOf(id);\n  let leftSiblings = state[parentId].children.slice(0, index);\n\n  if (length === -1) {\n    return leftSiblings;\n  }\n\n  if (length > leftSiblings.length) {\n    length = leftSiblings.length;\n  }\n\n  leftSiblings = _.reverse(leftSiblings);\n\n  leftSiblings.length = length;\n\n  return _.reverse(leftSiblings);\n};\n\nexport const getLeftSiblingId = (state, id) => {\n  const ids = getLeftSiblingIds(state, id, 1);\n  if (ids.length) {\n    return ids[0];\n  }\n\n  return undefined;\n};\n\nexport const getRightSiblingIds = (state, id, length = -1) => {\n  const parentId = getParentId(state, id);\n  const index = state[parentId].children.indexOf(id) + 1;\n  const rightSiblings = state[parentId].children.slice(index);\n\n  if (length === -1) {\n    return rightSiblings;\n  }\n\n  if (length > rightSiblings.length) {\n    length = rightSiblings.length;\n  }\n\n  rightSiblings.length = length;\n\n  return rightSiblings;\n};\n\nexport const getRightSiblingId = (state, id) => {\n  const ids = getRightSiblingIds(state, id, 1);\n  if (ids.length) {\n    return ids[0];\n  }\n\n  return undefined;\n};\n\nexport const getParentIds = (state, id, depth = -1) => {\n  let currentId = getParentId(state, id);\n\n  if (currentId === 'root') {\n    return [];\n  }\n\n  const parentIds = [];\n  let depthAt = 0;\n\n  while (currentId !== 'root') {\n    if (depth >= 0 && depthAt >= depth) {\n      break;\n    }\n    depthAt += 1;\n    parentIds.push(currentId);\n    currentId = getParentId(state, currentId);\n  }\n\n  return parentIds;\n};\n\nlet count = 0;\n\nconst getIndexesRecurse = (node, indexes, state) => {\n  if (node.children.length > 0) {\n    _.forEach(node.children, childId => {\n      if (indexes[childId] === undefined) {\n        indexes[childId] = count;\n        state[childId] = {\n          ...state[childId],\n          index: count\n        };\n\n        count += 1;\n      }\n      if (state[childId].children) {\n        indexes = getIndexesRecurse(state[childId], indexes, state);\n      }\n    });\n  }\n\n  if (indexes[node.id] === undefined) {\n    indexes[node.id] = count;\n\n    state[node.id] = {\n      ...state[node.id],\n      index: count\n    };\n\n    count += 1;\n  }\n\n  return indexes;\n};\n\nexport const getIndexes = nodes => {\n  const newNodes = { ...nodes };\n  count = 0;\n\n  getIndexesRecurse(newNodes.root, {}, newNodes);\n\n  newNodes.root = {\n    ...newNodes.root,\n    index: -1\n  };\n\n  return newNodes;\n};\n\nexport const reducerMoveNode = (state, payload) => {\n  if (payload.afterIndex !== undefined) {\n    const indexNode = _.find(state, n => n.id === payload.afterIndex);\n\n    if (indexNode.children.length && payload.makeChild) {\n      payload.first = true;\n      payload.parent = indexNode.id;\n    } else {\n      payload.after = indexNode.id;\n      payload.parent = indexNode.parent;\n    }\n  }\n\n  const { id, parent } = payload;\n\n  const parentId = parent || state[id].parent;\n  const oldParent = state[id].parent;\n\n  if (oldParent !== parentId) {\n    const updatedChildren = {};\n    const oldDepth = state[id].depth;\n    const newDepth = parentId === 'root' ? 0 : state[parentId].depth + 1;\n    const depthDiff = newDepth - oldDepth;\n\n    if (depthDiff !== 0 && state[id].children.length) {\n      const descendants = getAllDescendantIds(state, id);\n      _.forEach(descendants, childId => {\n        updatedChildren[childId] = Object.assign({}, state[childId], {\n          depth: state[childId].depth + depthDiff\n        });\n      });\n    }\n\n    return {\n      ...state,\n      ...updatedChildren,\n      [id]: {\n        ...state[id],\n        depth: newDepth,\n        parent: parentId\n      },\n      [oldParent]: {\n        ...state[oldParent],\n        children: children(state[oldParent].children, {\n          payload,\n          type: REMOVE_CHILD\n        })\n      },\n      [parentId]: {\n        ...state[parentId],\n        children: children(state[parentId].children, {\n          payload,\n          type: ORDER_CHILD\n        })\n      }\n    };\n  }\n\n  return {\n    ...state,\n    [parentId]: {\n      ...state[parentId],\n      children: children(state[parentId].children, {\n        payload,\n        type: ORDER_CHILD\n      })\n    }\n  };\n};\n\nexport const getPathPayloadAction = type => {\n  const act = (path, payload) => ({\n    path,\n    payload,\n    type\n  });\n\n  return act;\n};\n"]},"metadata":{},"sourceType":"module"}